
Development Tasks
=================

To Do
-----
- Ask the AI how to implement compiler tracing or debugging hooks.
- See if macros are also supposed to support closures.
- Investigate nested backquotes.
- OPTIMIZATION: Add a semantic analyzer after the macro expansion phase which
  can scan the AST for errors such as the wrong number or types of arguments to
  a primitive.  This would eliminate a lot of the runtime error checking
  currently in the primitive definitions and hence speed up the interpreter.
- implement stream IO primitives.
- implement packages.  A package x is a symbol in the global namespace which
  refers to another Environment instance which contains all the symbols of
  a package (lisp source file).  For any symbol y in the package p, this
  can be accessed with the notation p::y.
- Figure out how to make an environment scope that is parent to the GLOBAL
  Environment in which the built-ins are defined.  They cannot be redefined,
  only temporarily covered up by a descendent environment.
- Can we make the nil list immutable by subclassing LList, overriding all the
  mutating methods to make them report runtime errors.  Override __len__() to
  return 0 then perhaps the nil list would truly be immutable.
- Research how it might be possible to implement Scheme's tail recursion
  optimization in the evaluator.
- Investigate rewriting the evaluator as a loop that manages its own stack
  object and function calls.  Would it speed things up?  Would it simplify
  implementation of the tail recursion optimization?

Completed
---------
2026.02.17
- implement structs.

2026.02.16
- OPTIMIZATION: Move macro expansion completely out of expression evaluation.
  It should occur earlier (just after parsing).  Doing this will mean that
  macros are only expanded once instead of every time a line of code calling a
  macro is evaluated.

2026.02.15
- Implement an online (help &optional <symbol>) primitive which prints some
  documentation about the primitive, function or macro.
- Move all the help from the README.md to the online help in the interpreter.

2026.02.14
- Make the LispInterpreter._bindX methods take a tuple instead of a list for
  the argList parameter.  Right now other functions have to convert their
  tuples to lists before calling _bindArguments.

2026.01.29
- rewrite LispInterpreter._lbindArguments() to conform as much as possible to
  the common lisp standard document section 5.2.2. Lambda-Expressions.

2026.01.12
- make evaluations of undefined variables raise LispRuntimeError instead of
  evaluating to themselves.

2025.12.15
- Completed encapsulation of the common lisp interpreter into the LispInterpreter
  class.  It's now possible, if I choose, to implement a SchemeInterpreter
  class that reuses all of the remaining code.

2025.11.26
- The predicates have all been updated to lisp predicate names.  The old names
  which were of a more consistent naming pattern are aliased in library.lisp
  so that the ? names can still be used instead of the lisp names.
- bring the relational operations into alignment with common lisp.
- bring the arithmetic operations into alignment with common lisp.
- continue to bring other primitives into alignment with common lisp.

2025.11.25
- Update the lisp scanner to accept strings that include python style escape
  sequences.
- define a new global symbol t which stands for true and evaluates to itself.
- make all primitives use t and nil as the boolean values instead of 0 and nil.
- make nil the exclusive value for false.
- remove set!.  Fully replace with setf.
- implement let and let*.
- remove block primitive.
- remove def!, def!!.
